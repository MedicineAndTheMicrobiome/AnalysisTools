#!/usr/bin/env perl

###############################################################################

use strict;
use Getopt::Std;
use FileHandle;
use vars qw ($opt_r $opt_f $opt_x $opt_o $opt_I $opt_L);

getopts("r:f:x:o:I:L:");

my $PERC_ALGN_LEN=.9;
my $PERC_ID=.4;

my $usage = "
usage:
	$0

	-r <Reference genes hit list>
	-f <reference-to-BiGGReference mapping file, i.e., RFR to ECO>
	-x <BiGGReference-to-reaction mapping file, i.e., ECO to reactions>
	-o <output filename>

	[-I <Alignment Identity, ie. .40 is 40%>]
	[-L <Alignment Length as proportion, ie. .90 is 90%>]

Summary:

	This script will generate a list of reactions that could be active or associated with
	the list of genes specified in the hit list (-r).

Output: Active vs. Associated:

	A reaction is considered associated if any gene in the GPR for a reaction is found.  
	This is the loosest evidence for the potential capability in the specified gene list.
	For an active reaction, the reaction's gene rules were satisfied.  This is output (-o)

	The -f flag is the mapping of the Reference to the BiGG Reference.  The Reference
	could be any set of genes that have been mapped (blastp) with some degree of confidence
	against the BiGG references.  The BiGG references are a set of peptides that have been
	genome scale reconstructed and associated with reactions.  There are not very many
	of these.   There should be only one reference to BiGG reference map.  These act as a
	proxy from the reference peptides to the GPRs.

	The -x flag is essentially just a list of GPRs.  These were extracted from the
	genome scale reconstructed organisms.  

Algorithm:

	The script works by first loading the reference gene hit list.  From the reference
	gene hit list, a list of BiGG Reference gene hit is generated by mapping/translation.
	This new list of genes have high confidence reactions associated with them, 
	because they are from the BiGG database.  Each of these BiGG genes is used as a proxy
	for the reference gene.  

	Next, for each reaction in the GPR list, the genes in the rule are looked up in the proxy list and
	the GPR equation is evaluated as a boolean expression.  If the expression evaluates to
	true, then all the reactions associated with the gene is added to the Active list.  If
	any of the genes in the GPR are in the proxy list, then the Associated list is updated.
	
	In theory, if you have all the genes identified in the (-r) reference genes list,
	then you should be able to reconstruct a genome scale model and you will want to focus
	on the \"active\" list.  If you are sampling genes from a metagenomic/transcriptomic
	sample, then you may not have acquired all the genes necessary for the reaction according
	to the GPR.  In this case, you can focus on the \"associated\" list.

Filtering:

	Since the presence or absence of a gene in the sample is specified by the -r parameter,
	any filtering to determine what should or should not be included in this list needs 
	to be a preprocessing step.
	
";

###############################################################################

if(!defined($opt_r) || !defined($opt_f) || !defined($opt_x) || !defined($opt_o)){
	die $usage;
}

my $ref_hits_fname=$opt_r;
my $ref_to_BiGGref_fname=$opt_f;
my $BiGGref_to_reaction_fname=$opt_x;
my $output_fname=$opt_o;
my $ref_align_length_cutoff=$opt_L;
my $ref_align_identity_cutoff=$opt_I;

if(!defined($ref_align_length_cutoff)){
	$ref_align_length_cutoff=$PERC_ALGN_LEN;
}

if(!defined($ref_align_identity_cutoff)){
	$ref_align_identity_cutoff=$PERC_ID;
}

print STDERR "Percent of alignment length cutoff: " . $ref_align_length_cutoff*100 . "%\n";
print STDERR "Percent of alignment identify cutoff: " . $ref_align_identity_cutoff*100 . "%\n";

###############################################################################
# Function for loading input files

sub load_ref_to_BiGGref{
	my $fname=shift;
	my $ref_align_length_cutoff=shift;
	my $ref_align_identity_cutoff=shift;

	# Format:
	# 	RefID, RefPC, RefLen, BiGGRefID, BiGGRefPC, BiGGRefLen, alignID, alignLen, BitScore, Eval

	print STDERR "Loading Reference to BiGG Reference Mapping...\n";
	open(FH, "<$fname") || die "Could not open $fname for reading.\n";

	my %ref_to_BiGGref_hash;
	while(<FH>){
		chomp;

		my @col=split "\t", $_;
		
		my $ref_id=$col[0];
		my $bigg_id=$col[3];

		my $bigg_ref_len=$col[5];
		my $align_id=$col[6];
		my $align_len=$col[7];
		
		my $perc_of_bigg_ref_aligned=$align_len/$bigg_ref_len;
		my $alignment_identify=$align_id/100;

		if(
			($perc_of_bigg_ref_aligned>=$ref_align_length_cutoff) &&
			($alignment_identify>=$ref_align_identity_cutoff)
		){
			push @{$ref_to_BiGGref_hash{$ref_id}}, $bigg_id;
		}
	}
	close(FH);

	print STDERR "Done.\n";
	return(\%ref_to_BiGGref_hash);
}

#------------------------------------------------------------------------------

sub GPR_to_perlstr{
	# Convert GPR rule into a standard perl boolean expression 
	my $str=shift;
	$str=~s/or/||/g;
	$str=~s/and/&&/g;
	return($str);
}

sub load_BiGGref_to_reaction{
	my $fname=shift;

	# Format:
	# 	OrgID, RxnID, RxnDesc, RxnEq, GPR

	print STDERR "Loading GPRs...\n";
	open(FH, "<$fname") || die "Could not open $fname for reading.\n";

	my @gpr_arr;
	my @rxneq_arr;

	my %rules_hash;
	my %free_hash;
	my %rxn_info;

	my $i=0;

	while(<FH>){
		chomp;
		my @col=split "\t", $_;

		my $org_id=$col[0];
		my $rxn_id=$col[1];
		my $rxn_desc=$col[2];
		my $rxn_eq=$col[3];
		my $gpr_str=$col[4];

		# Convert GPR symbols to standard math
		#print STDERR "$gpr_str\n";
		my $perl_str=GPR_to_perlstr($gpr_str);
		#print STDERR "key: $perl_str\n";

		# Store by GPR rule
		if($perl_str ne ""){
			# Append the organism id and reaction id, so the rule is unique
			$perl_str="$rxn_id:$org_id:$perl_str";
			$rules_hash{$perl_str}=$rxn_id;
			$i++;
		}else{
			# If there is no GPR associated, the reaction is for free
			$free_hash{$rxn_id}=1;
		}

		$rxn_info{"$rxn_id"}="$rxn_desc\t$rxn_eq";
	}

	close(FH);

	print STDERR "Done.\n";	
	print STDERR "$i GPRs loaded.\n";

	return(\%rules_hash, \%free_hash, \%rxn_info);
	
}

#------------------------------------------------------------------------------

sub load_reference_hits{
	# Just loads a single column file into a hash
	my $fname=shift;

	# Format:
	# 	RefID
	
	print STDERR "Loading reference hits...\n";
	open(FH, "<$fname") || die "Could not open $fname for reading.\n";

	my %genes;
	my $i=0;
	while(<FH>){
		chomp;
		my @col=split "\t", $_;
		$genes{$col[0]}=1;
		$i++;
	}	
	
	close(FH);

	print STDERR "Done.\n";
	print STDERR "$i reference gene hits loaded.\n";
	return(\%genes);
}

###############################################################################
###############################################################################
# Beginning main code here:

###############################################################################
# Load data files

# Example: 
#
# rfr:Rfer_4465 -> ppu:PP_3890
#
my $ref_to_bref_hash_ref=load_ref_to_BiGGref($ref_to_BiGGref_fname,
	$ref_align_length_cutoff,
	$ref_align_identity_cutoff
    );

# Example:
#
# sau: (SA0913) && (SA0910) && (SA0911) && (SA0937) && (SA0912) && (SA0938) -> CYTBD
# 
# Maps to an array of reaction IDs
#
my ($rules_hash_ref, $free_hash_ref, $rxn_desc_hash_ref)=load_BiGGref_to_reaction($BiGGref_to_reaction_fname);

# Example:
# 
# rfr:Rfer_0003
#
my $ref_hits_hash_ref=load_reference_hits($ref_hits_fname);

###############################################################################
# Map ref_hits to BiGG references proxy
#

my %BiGGref_hits;
my %BiGGref_nohits;
my $num_BiGGref_hits=0;

foreach my $ref_id(keys %{$ref_hits_hash_ref}){
	my $biggref_arr_ref=${$ref_to_bref_hash_ref}{$ref_id};
	
	if(!defined($biggref_arr_ref)){
		$BiGGref_nohits{$ref_id}=1;	
		#print STDERR "no hits for $ref_id\n";
	}else{
		foreach my $biggref_id (@{$biggref_arr_ref}){
			$BiGGref_hits{$biggref_id}++;
		}
	}
}

#foreach my $bigg_ref_id(keys %BiGGref_hits){
#	print STDERR "$bigg_ref_id\n";
#}

###############################################################################
# Subroutines for testing GPR activity
#

sub pull_gene_ids_from_GPR{
	# Extract a list of genes associated with the GPR
	my $str=shift;
	#print "In: $str\n";
	$str=~s/\(//g;
	$str=~s/\)//g;
	$str=~s/\|\|//g;
	$str=~s/&&//g;
	$str=~s/ +/,/g;
	#print "Out: $str\n";
	my @genes=split ",", $str;
	return(\@genes);
}

sub test_gpr{
	# For a GPR, pull out all the proxy genes, determine if they were considered
	# present in the reference gene list and evaluate the GPR equation.
	my $gpr=shift;
	my $bigg_ref_hits=shift;
	
	my ($rxn_id, $org_id, $gpr_eq)=split ":", $gpr;
	my $gene_ids_arr_ref=pull_gene_ids_from_GPR($gpr_eq);
	
	my $any_association=0;

	#print STDERR "$gpr_eq\n";
	# Go through and substitute the gene name with whether it is present or not
	foreach my $gene_id(@{$gene_ids_arr_ref}){
		my $value=${$bigg_ref_hits}{"$org_id:$gene_id"};	
		if(!defined($value)){
			$value=0;
		}else{
			$any_association++;
		}
		#print STDERR "\t$gene_id = $value\n";
		$gpr_eq=~s/$gene_id/$value/g;
	}

	# Compute the binary value of the GPR
	my $rule_value=eval($gpr_eq);
	#print STDERR "$gpr_eq =  $rule_value\n";

	return($rule_value, $any_association, $gpr_eq);
}

###############################################################################
# Output

open(ACTIVE_FH, ">$output_fname\.active.tsv") || die "Could not open $output_fname\.active.tsv for writing.\n";
open(RELATED_FH, ">$output_fname\.associated.tsv") || die "Could not open $output_fname\.associated.tsv for writing.\n";

my $header=join "\t", (
	"RxnID",
	"RxnDesc",
	"RxnEq",
	"Organism",
	"GPR / Values"
);

print ACTIVE_FH "# $header\n";
print RELATED_FH "# $header\n";

sub print_array{
	my $gpr=shift;
	my $fh=shift;
	my $desc_hash_ref=shift;
	my $gpr_eq=shift;
	my ($rxn_id, $org_id, $gpr_perl)=split ":", $gpr;
	print {$fh} "$rxn_id\t${$desc_hash_ref}{$rxn_id}\t$org_id\t$gpr_perl / $gpr_eq\n";
}

foreach my $gpr(sort keys %{$rules_hash_ref}){
	#print STDERR "$gpr\n";

	my ($active, $related, $gpr_eq)=test_gpr($gpr, \%BiGGref_hits);	

	#print STDERR "$gpr ($gpr_eq): $active / $related\n";
	# $gpr example: eco:2AGPGAT181:(b2836)

	if($active){
		print_array($gpr, \*ACTIVE_FH, $rxn_desc_hash_ref, $gpr_eq);
	}

	if($related){
		print_array($gpr, \*RELATED_FH, $rxn_desc_hash_ref, $gpr_eq);
	}

}

close(ACTIVE_FH);
close(RELATED_FH);

###############################################################################

`cut -f 1,2,3 $output_fname\.active.tsv | sort -u > $output_fname\.active.unique.tsv`;
`cut -f 1,2,3 $output_fname\.associated.tsv | sort -u > $output_fname\.associated.unique.tsv`;

###############################################################################

print STDERR "Done.\n";

